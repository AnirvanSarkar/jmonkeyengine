/*
 * Copyright (c) 2009-2025 jMonkeyEngine
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jme3.font;

import com.jme3.export.InputCapsule;
import com.jme3.export.JmeExporter;
import com.jme3.export.JmeImporter;
import com.jme3.export.OutputCapsule;
import com.jme3.export.Savable;
import com.jme3.material.Material;

import java.io.IOException;

/**
 * Represents a font loaded from a bitmap font definition
 * (e.g., generated by <a href="https://libgdx.com/wiki/tools/hiero">AngelCode Bitmap Font Generator</a>).
 * It manages character sets, font pages (textures), and provides utilities for text measurement and rendering.
 *
 * @author dhdd
 * @author Yonghoon
 */
public class BitmapFont implements Savable {

    /**
     * Specifies horizontal alignment for text.
     *
     * @see BitmapText#setAlignment(com.jme3.font.BitmapFont.Align)
     */
    public enum Align {

        /**
         * Align text on the left of the text block
         */
        Left,

        /**
         * Align text in the center of the text block
         */
        Center,

        /**
         * Align text on the right of the text block
         */
        Right
    }

    /**
     * Specifies vertical alignment for text.
     *
     * @see BitmapText#setVerticalAlignment(com.jme3.font.BitmapFont.VAlign)
     */
    public enum VAlign {
        /**
         * Align text on the top of the text block
         */
        Top,

        /**
         * Align text in the center of the text block
         */
        Center,

        /**
         * Align text at the bottom of the text block
         */
        Bottom
    }

    // The character set containing definitions for each character (glyph) in the font.
    private BitmapCharacterSet charSet;
    // An array of materials, where each material corresponds to a font page (texture).
    private Material[] pages;
    // Indicates whether this font is designed for right-to-left (RTL) text rendering.
    private boolean rightToLeft = false;
    // For cursive bitmap fonts in which letter shape is determined by the adjacent glyphs.
    private GlyphParser glyphParser;

    /**
     * Creates a new instance of `BitmapFont`.
     * This constructor is primarily used for deserialization.
     */
    public BitmapFont() {
    }

    /**
     * Creates a new {@link BitmapText} instance initialized with this font.
     * The label's size will be set to the font's rendered size, and its text content
     * will be set to the provided string.
     *
     * @param content The initial text content for the label.
     * @return A new {@link BitmapText} instance.
     */
    public BitmapText createLabel(String content) {
        BitmapText label = new BitmapText(this);
        label.setSize(getCharSet().getRenderedSize());
        label.setText(content);
        return label;
    }

    /**
     * Checks if this font is configured for right-to-left (RTL) text rendering.
     *
     * @return true if this is a right-to-left font, otherwise false (default is left-to-right).
     */
    public boolean isRightToLeft() {
        return rightToLeft;
    }

    /**
     * Specifies whether this font should be rendered as right-to-left (RTL).
     * By default, it is set to false (left-to-right).
     *
     * @param rightToLeft true to enable right-to-left rendering; false for left-to-right.
     */
    public void setRightToLeft(boolean rightToLeft) {
        this.rightToLeft = rightToLeft;
    }

    /**
     * Returns the preferred size of the font, which is typically its rendered size.
     *
     * @return The preferred size of the font in font units.
     */
    public float getPreferredSize() {
        return getCharSet().getRenderedSize();
    }

    /**
     * Sets the character set for this font. The character set contains
     * information about individual glyphs, their positions, and kerning data.
     *
     * @param charSet The {@link BitmapCharacterSet} to associate with this font.
     */
    public void setCharSet(BitmapCharacterSet charSet) {
        this.charSet = charSet;
    }

    /**
     * Sets the array of materials (font pages) for this font. Each material
     * corresponds to a texture page containing character bitmaps.
     * The character set's page size is also updated based on the number of pages.
     *
     * @param pages An array of {@link Material} objects representing the font pages.
     */
    public void setPages(Material[] pages) {
        this.pages = pages;
        charSet.setPageSize(pages.length);
    }

    /**
     * Retrieves a specific font page material by its index.
     *
     * @param index The index of the font page to retrieve.
     * @return The {@link Material} for the specified font page.
     * @throws IndexOutOfBoundsException if the index is out of bounds.
     */
    public Material getPage(int index) {
        return pages[index];
    }

    /**
     * Returns the total number of font pages (materials) associated with this font.
     *
     * @return The number of font pages.
     */
    public int getPageSize() {
        return pages.length;
    }

    /**
     * Retrieves the character set associated with this font.
     *
     * @return The {@link BitmapCharacterSet} of this font.
     */
    public BitmapCharacterSet getCharSet() {
        return charSet;
    }

    /**
     * For cursive fonts a GlyphParser needs to be specified which is used
     * to determine glyph shape by the adjacent glyphs. If nothing is set,
     * all glyphs will be rendered isolated.
     *
     * @param glyphParser the desired parser (alias created) or null for none
     *     (default=null)
     */
    public void setGlyphParser(GlyphParser glyphParser) {
        this.glyphParser = glyphParser;
    }

    /**
     * @return The GlyphParser set on the font, or null if it has no glyph parser.
     */
    public GlyphParser getGlyphParser() {
        return glyphParser;
    }

    /**
     * Gets the line height of a StringBlock.
     *
     * @param sb the block to measure (not null, unaffected)
     * @return the line height
     */
    float getLineHeight(StringBlock sb) {
        return charSet.getLineHeight() * (sb.getSize() / charSet.getRenderedSize());
    }

    public float getCharacterAdvance(char curChar, char nextChar, float size) {
        BitmapCharacter c = charSet.getCharacter(curChar);
        if (c == null)
            return 0f;

        float advance = size * c.getXAdvance();
        advance += c.getKerning(nextChar) * size;
        return advance;
    }

    private int findKerningAmount(int newLineLastChar, int nextChar) {
        BitmapCharacter c = charSet.getCharacter(newLineLastChar);
        if (c == null)
            return 0;
        return c.getKerning(nextChar);
    }

    /**
     * Calculates the width of the given text in font units.
     * This method accounts for character advances, kerning, and line breaks.
     * It also attempts to skip custom color tags (e.g., "\#RRGGBB#" or "\#RRGGBBAA#")
     * based on a specific format.
     * <p>
     * Note: This method calculates width in "font units" where the font's
     * {@link BitmapCharacterSet#getRenderedSize() rendered size} is the base.
     * Actual pixel scaling for display is typically handled by {@link BitmapText}.
     *
     * @param text The text to measure.
     * @return The maximum line width of the text in font units.
     */
    public float getLineWidth(CharSequence text) {
        // This method will probably always be a bit of a maintenance
        // nightmare since it bases its calculation on a different
        // routine than the Letters class.  The ideal situation would
        // be to abstract out letter position and size into its own
        // class that both BitmapFont and Letters could use for
        // positioning.
        // If getLineWidth() here ever again returns a different value
        // than Letters does with the same text then it might be better
        // just to create a Letters object for the sole purpose of
        // getting a text size.  It's less efficient but at least it
        // would be accurate.

        // And here I am mucking around in here again...
        //
        // A font character has a few values that are pertinent to the
        // line width:
        //  xOffset
        //  xAdvance
        //  kerningAmount(nextChar)
        //
        // The way BitmapText ultimately works is that the first character
        // starts with xOffset included (ie: it is rendered at -xOffset).
        // Its xAdvance is wider to accommodate that initial offset.
        // The cursor position is advanced by xAdvance each time.
        //
        // So, a width should be calculated in a similar way.  Start with
        // -xOffset + xAdvance for the first character and then each subsequent
        // character is just xAdvance more 'width'.
        //
        // The kerning amount from one character to the next affects the
        // cursor position of that next character and thus the ultimate width
        // and so must be factored in also.

        float lineWidth = 0f;
        float maxLineWidth = 0f;
        char lastChar = 0;
        boolean firstCharOfLine = true;
//        float sizeScale = (float) block.getSize() / charSet.getRenderedSize();
        float sizeScale = 1f;

        // Use GlyphParser if available for complex script shaping (e.g., cursive fonts).
        CharSequence processedText = glyphParser != null ? glyphParser.parse(text) : text;

        for (int i = 0; i < processedText.length(); i++) {
            char currChar = processedText.charAt(i);
            if (currChar == '\n') {
                maxLineWidth = Math.max(maxLineWidth, lineWidth);
                lineWidth = 0f;
                firstCharOfLine = true;
                continue;
            }
            BitmapCharacter c = charSet.getCharacter(currChar);
            if (c != null) {
                // Custom color tag skipping logic:
                // Assumes tags are of the form `\#RRGGBB#` (9 chars total) or `\#RRGGBBAA#` (12 chars total).
                if (currChar == '\\' && i < processedText.length() - 1 && processedText.charAt(i + 1) == '#') {
                    // Check for `\#XXXXX#` (6 chars after '\', including final '#')
                    if (i + 5 < processedText.length() && processedText.charAt(i + 5) == '#') {
                        i += 5;
                        continue;
                    }
                    // Check for `\#XXXXXXXX#` (9 chars after '\', including final '#')
                    else if (i + 8 < processedText.length() && processedText.charAt(i + 8) == '#') {
                        i += 8;
                        continue;
                    }
                }
                if (!firstCharOfLine) {
                    lineWidth += findKerningAmount(lastChar, currChar) * sizeScale;
                } else {
                    if (rightToLeft) {
                        // Ignore offset, so it will be compatible with BitmapText.getLineWidth().
                    } else {
                        // The first character needs to add in its xOffset, but it
                        // is the only one... and negative offsets = positive width
                        // because we're trying to account for the part that hangs
                        // over the left.  So we subtract.
                        lineWidth -= c.getXOffset() * sizeScale;
                    }
                    firstCharOfLine = false;
                }
                float xAdvance = c.getXAdvance() * sizeScale;

                // If this is the last character of a line, then we really should
                // have only added its width. The advance may include extra spacing
                // that we don't care about.
                if (i == processedText.length() - 1 || processedText.charAt(i + 1) == '\n') {
                    if (rightToLeft) {
                        // In RTL text we move the letter x0 by its xAdvance, so
                        // we should add it to lineWidth.
                        lineWidth += xAdvance;
                        // Then we move letter by its xOffset.
                        // Negative offsets = positive width.
                        lineWidth -= c.getXOffset() * sizeScale;
                    } else {
                        lineWidth += c.getWidth() * sizeScale;
                        // Since the width includes the xOffset then we need
                        // to take it out again by adding it, ie: offset the width
                        // we just added by the appropriate amount.
                        lineWidth += c.getXOffset() * sizeScale;
                    }
                } else {
                    lineWidth += xAdvance;
                }
            }
        }
        return Math.max(maxLineWidth, lineWidth);
    }

    /**
     * Merges another {@link BitmapFont} into this one.
     * This operation combines the character sets and font pages.
     * If both fonts contain the same style, the merge will fail and throw a RuntimeException.
     *
     * @param newFont The {@link BitmapFont} to merge into this one. It must have a style assigned.
     */
    public void merge(BitmapFont newFont) {
        charSet.merge(newFont.charSet);
        final int size1 = this.pages.length;
        final int size2 = newFont.pages.length;

        Material[] tmp = new Material[size1 + size2];
        System.arraycopy(this.pages, 0, tmp, 0, size1);
        System.arraycopy(newFont.pages, 0, tmp, size1, size2);

        this.pages = tmp;
    }

    /**
     * Sets the style for the font's character set.
     * This method is typically used when a font file contains only one style
     * but needs to be assigned a specific style identifier for merging
     * with other multi-style fonts.
     *
     * @param style The integer style identifier to set.
     */
    public void setStyle(int style) {
        charSet.setStyle(style);
    }

    @Override
    public void write(JmeExporter ex) throws IOException {
        OutputCapsule oc = ex.getCapsule(this);
        oc.write(charSet, "charSet", null);
        oc.write(pages, "pages", null);
        oc.write(rightToLeft, "rightToLeft", false);
        oc.write(glyphParser, "glyphParser", null);
    }

    @Override
    public void read(JmeImporter im) throws IOException {
        InputCapsule ic = im.getCapsule(this);
        charSet = (BitmapCharacterSet) ic.readSavable("charSet", null);
        Savable[] pagesSavable = ic.readSavableArray("pages", null);
        pages = new Material[pagesSavable.length];
        System.arraycopy(pagesSavable, 0, pages, 0, pages.length);
        rightToLeft = ic.readBoolean("rightToLeft", false);
        glyphParser = (GlyphParser) ic.readSavable("glyphParser", null);
    }
}
